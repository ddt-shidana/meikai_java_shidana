/********************
 * 第1章			*
 *	 演習1-1（p13）	*
 *******************/

/* [メソッド]	（複数のクラスをグループ化するため、）パッケージを用意します。
 * [引数]		パッケージ名「ensyu1_1」
 */
package ensyu1_1;

/* [アクセス修飾子]		public（一番広い）レベルで、
 * [メソッド]			～の処理を開始します。
 * [引数]				プログラムファイル名「Ensyu1_1」
 */
//ここからのクラスたちは「Ensy1_1」というパッケージに収納されます。

public class Ensyu1_1 {
// ↓ここから「Ensyu1_1」クラスの中に招待するメンバを紹介します。
//		※メンバはメソッド・フィールド・コンストラクタ・innerクラスのどこかに所属しています。

	/* [アクセス修飾子]		public（一番広い）レベルで、
	 * [static修飾子]		インスタンス化（=new）せずに使えるように、
	 * [メソッドの戻り値]	戻り値無しで、
	 * [メソッド]			～を他から呼ばれることは無く、一番最初に実行します。
	 * [引数]
	 * 		＜引数の型＞		～をstring型の配列で受け取ります。
	 * 		＜引数名＞			引数名「args」
	 */

//		※コンストラクタ所属のメンバはいません。
//		※ついでにinnerクラス所属のメンバもいません。

	/* 	＜補足＞引数の型を"String"にしている理由について
	 * 		私		がこの場で命令をするのに使っている道具は、
	 * 				人間界でいうと 文字・文字列（=String） です。
	 * 						ですので、
	 * 		実行者	がコマンドライン（キーボードだけで操作する画面(=CUI)上の入力行）から
	 * 				受け取る値も、文字・文字列（=String）として扱ってもらいたいのです。
	 */
	public static void main(String[] args) {

	//※ここからmainメソッドの[処理内容]です。
		/* [メソッド]
		 * 	＜クラス＞	java.lngパッケージからSystemクラスを呼んできます。
		 * 		＜フィールド＞	Systemクラスの中でデータの値を保管するためにoutフィードという空間を使います。
		 * 						保管するデータ値の型はPrintStreamクラス（java.ioパッケージ所属）です。
		 * 						PrintStreamクラスは引数のデータ型毎にprintlnメソッドが用意されているので、
		 * 						どのメソッドを使うのかを指示します。
		 * 			＜printlnメソッド＞	～を出力します。
		 * [引数]
		 * 	「セミコロンが欠如しているとどうなるか。」
		 */


		System.out.println("セミコロンが欠如しているとどうなるか。")


		/* 以下のポップアップが表示されました。
		 *
		 *	「	ワークスペースでエラー
		 *				必要なプロジェクトでエラー：
		 *					[プロジェクト名]
		 *				起動を続行しますか？
		 *					□常に確認なしで起動する	」
		 *
		 * 確認したところ、読点「;」が抜けておりました。
		 * 正しい命令は以下になります。
		 * 		System.out.println("セミコロンが欠如しているとどうなるか。");
		 *
		 * 大変申し訳ありませんでした。
		 * 今後とも私のことを宜しくお願い致しますTT
		 */

	// ↑mainメソッドの[処理内容]はここまでです。
	//（ここまで指示を受け取ってくれてないですよね。）
	}

// ↑これにて「Ensyu1_1」クラス内に招待するメンバの説明を終わります。
//（もちろんここも聞いてくれなかったですね・・・・・・）
}
